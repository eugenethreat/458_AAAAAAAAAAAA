"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 *
 * This is a sketch to make resource creation and management easier.
 *
 * status: ALPHA
 */
const lodash_1 = tslib_1.__importDefault(require("lodash"));
// this means server needs to import lang
const lang_1 = require("@supercollider/lang");
const server_1 = tslib_1.__importStar(require("@supercollider/server"));
/**
 * scsynth Group
 *
 * See `server.group(...)`
 */
class Group {
    constructor(server, id) {
        this.id = id;
        this.server = server;
    }
    /**
     * Stop the Group and remove it from the play graph on the server.
     */
    free() {
        this.server.send.msg(server_1.msg.nodeFree(this.id));
        return server_1.whenNodeEnd(this.server, String(this.id), this.id);
    }
    /**
     * Update control parameters on the Synth.
     *
     * @example
     * ```js
     * synth.set({freq: 441, amp: 0.9});
     * ```
     *
     * This method works for Group and Synth.
     * For a Group it sends the set message to all children Synths
     * in the Group.
     */
    set(settings) {
        this.server.send.msg(server_1.msg.nodeSet(this.id, settings));
    }
}
exports.Group = Group;
/**
 * Created with `server.synth(...)`
 *
 * Extends Group
 */
class Synth extends Group {
}
exports.Synth = Synth;
/**
 * scsynth audio bus
 *
 * See `server.audioBus(...)`
 *
 * These bus numbers (ids) and numChannels are allocated here in the client.
 * The server only gets bus ids for reading and writing to.
 */
class AudioBus {
    constructor(server, id, numChannels) {
        this.server = server;
        this.id = id;
        this.numChannels = numChannels;
    }
    /**
     * Deallocate the AudioBus, freeing it for resuse.
     */
    free() {
        this.server.state.freeAudioBus(this.id, this.numChannels);
    }
}
exports.AudioBus = AudioBus;
/**
  * scsynth control bus

  * See `server.controlBus(...)`
  *
  * These bus numbers (ids) and numChannels are allocated here in the client.
  * The server only gets bus ids for reading and writing to.
  */
class ControlBus extends AudioBus {
    /**
     * Deallocate the ControlBus, freeing it for resuse.
     */
    free() {
        this.server.state.freeControlBus(this.id, this.numChannels);
    }
}
exports.ControlBus = ControlBus;
/**
 * scsynth Buffer
 *
 * See `server.buffer(...)` and `server.readBuffer(...)`
 */
class Buffer {
    constructor(server, id, numFrames, numChannels) {
        this.server = server;
        this.id = id;
        this.numFrames = numFrames;
        this.numChannels = numChannels;
    }
    /**
     * Deallocate the Buffer, freeing memory on the server.
     */
    async free() {
        await this.server.callAndResponse(server_1.msg.bufferFree(this.id));
        this.server.state.freeBuffer(this.id, this.numChannels);
    }
}
exports.Buffer = Buffer;
/**
 * scsynth SynthDef
 *
 * See `server.synthDefs(...)`
 *
 * These are currently compiled using sclang,
 * and the synthDefResult holds metadata about the compiled
 * synthdef and the raw compiled bytes.
 *
 * The SynthDef may have been compiled from a sourceCode string
 * or compiled from a file at path.
 */
class SynthDef {
    constructor(server, defName, synthDefResult, sourceCode, path) {
        this.server = server;
        this.name = defName;
        this.synthDefResult = synthDefResult;
        this.sourceCode = sourceCode;
        this.path = path;
        // SynthDefCompiler will watch the path
    }
}
exports.SynthDef = SynthDef;
/**
 * Supplied to synthDefs
 */
// interface SynthDefsArgs {
//   [defName: string]: {
//     source?: string;
//     path?: string;
//   };
// }
/**
 * This extends Server with convienient methods for creating Synth, Group, compiling SynthDefs, creating Buses, Buffers etc.
 *
 * All methods return Promises, and all arguments accept Promises.
 * This means that async actions (like starting a sclang interpreter,
 * compiling SynthDefs and sending them to the server) are complete and their results
 * are ready to be used by whatever they have been supplied to.
 */
class ServerPlus extends server_1.default {
    /**
     * Create a Synth on the server
     */
    async synth(synthDef, args = {}, group, addAction = server_1.msg.AddActions.TAIL) {
        const [def, g] = await Promise.all([Promise.resolve(synthDef), Promise.resolve(group)]);
        const nodeId = this.state.nextNodeID();
        // src/ServerPlus.ts:236:29 - error TS2532: Object is possibly 'undefined'. ?
        const sn = server_1.msg.synthNew(def.synthDefResult.name, nodeId, addAction, g ? g.id : 0, args);
        this.send.msg(sn);
        await server_1.whenNodeGo(this, String(nodeId), nodeId);
        return new Synth(this, nodeId);
    }
    // grainSynth with no id
    /**
     * Create a Group on the server
     */
    async group(group, addAction = server_1.msg.AddActions.TAIL) {
        const g = await Promise.resolve(group);
        const nodeId = this.state.nextNodeID();
        const sn = server_1.msg.groupNew(nodeId, addAction, g ? g.id : 0);
        this.send.msg(sn);
        await server_1.whenNodeGo(this, String(nodeId), nodeId);
        return new Group(this, nodeId);
    }
    get synthDefCompiler() {
        if (!this._synthDefCompiler) {
            this._synthDefCompiler = new lang_1.SynthDefCompiler();
        }
        return this._synthDefCompiler;
    }
    /**
     * Compile multiple SynthDefs either from source or path.
     * If you have more than one to compile then always use this
     * as calling `server.synthDef` multiple times will start up
     * multiple supercollider interpreters. This is harmless, but
     * very inefficient.
     *
     * @param defs - An object with `{defName: spec, ...}` where spec is
     *               an object like `{source: "SynthDef('noise', { ...})"}`
     *               or `{path: "./noise.scd"}`
     * @returns An object with the synthDef names as keys and Promises as values.
     *                    Each Promise will resolve with a SynthDef.
     *                    Each Promises can be supplied directly to `server.synth()`
     */
    synthDefs(defs) {
        const compiling = this.synthDefCompiler.boot().then(() => {
            return this.synthDefCompiler.compileAndSend(defs, this);
        });
        return lodash_1.default.mapValues(defs, async (requested, name) => {
            // for each def await the same promise which returns a dict
            const defsMap = await compiling;
            const result = defsMap[name];
            if (!result) {
                new Error(`${name} not found in compiled SynthDefs`);
            }
            const sourceCode = result.synthDesc.sourceCode;
            const synthDef = new SynthDef(this, result.name, result, sourceCode, "path" in requested ? requested.path : undefined);
            return synthDef;
        });
    }
    async _compileSynthDef(defName, sourceCode, path) {
        await this.synthDefCompiler.boot();
        let compileRequest;
        if (sourceCode) {
            compileRequest = { source: sourceCode };
        }
        else if (path) {
            compileRequest = { path: path };
        }
        else {
            throw new Error(`Neither sourceCode nor path supplied for compileSynthDef ${defName}`);
        }
        const defs = await this.synthDefCompiler.compileAndSend({
            [defName]: compileRequest,
        }, this);
        // what if defName does not match synthDefResult.name ?
        const synthDefResult = defs[defName];
        if (!synthDefResult) {
            throw new Error(`SynthDefResult not found ${defName} in synthDefCompiler return values: ${defs}`);
        }
        return new SynthDef(this, defName, synthDefResult, sourceCode, path);
    }
    /**
     * Load and compile a SynthDef from path and send it to the server.
     */
    loadSynthDef(defName, path) {
        return this._compileSynthDef(defName, undefined, path);
    }
    /**
     * Compile a SynthDef from supercollider source code and send it to the server.
     */
    synthDef(defName, sourceCode) {
        return this._compileSynthDef(defName, sourceCode);
    }
    /**
     * Allocate a Buffer on the server.
     */
    async buffer(numFrames, numChannels = 1) {
        const id = this.state.allocBufferID(numChannels);
        await this.callAndResponse(server_1.msg.bufferAlloc(id, numFrames, numChannels));
        return new Buffer(this, id, numFrames, numChannels);
    }
    /**
     * Allocate a Buffer on the server and load a sound file into it.
     *
     * Problem: scsynth uses however many channels there are in the sound file,
     * but the client (sclang or supercolliderjs) doesn't know how many there are.
     */
    async readBuffer(path, numChannels = 2, startFrame = 0, numFramesToRead = -1) {
        const id = this.state.allocBufferID(numChannels);
        await this.callAndResponse(server_1.msg.bufferAllocRead(id, path, startFrame, numFramesToRead));
        return new Buffer(this, id, numFramesToRead, numChannels);
    }
    /**
     * Allocate an audio bus.
     */
    audioBus(numChannels = 1) {
        // TODO: should be a promise that rejects if you run out of busses
        const id = this.state.allocAudioBus(numChannels);
        return new AudioBus(this, id, numChannels);
    }
    /**
     * Allocate a control bus.
     */
    controlBus(numChannels = 1) {
        const id = this.state.allocControlBus(numChannels);
        return new ControlBus(this, id, numChannels);
    }
}
exports.default = ServerPlus;
/**
 * Start the scsynth server with options:
 *
 * ```js
 *   let server = await sc.server.boot({device: 'Soundflower (2ch)'});
 * ```
 *
 * @memberof server
 *
 * @param options - Optional command line options for server
 * @param store - optional external Store to hold Server state
 */
async function boot(options, store) {
    const s = new ServerPlus(options, store);
    await s.boot();
    await s.connect();
    return s;
}
exports.boot = boot;
//# sourceMappingURL=ServerPlus.js.map