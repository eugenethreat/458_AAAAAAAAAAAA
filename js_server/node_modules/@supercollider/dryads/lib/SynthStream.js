"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const server_1 = require("@supercollider/server");
const dryadic_1 = require("dryadic");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const Group_1 = tslib_1.__importDefault(require("./Group"));
const { AddActions, nodeFree, synthNew } = server_1.msg;
const LATENCY = 0.03;
/**
 * Given a Bacon.js stream that returns objects, this spawns a series of Synths.
 *
 * Properties:
 *  {Bacon.EventStream} stream
 *  {object} defaultParams
 *
 * The event values should be simple JavaScript objects:
 *
 * {
 *   defName: 'synthDefName',
 *   args: {
 *     out: 0,
 *     freq: 440
 *   }
 * }
 *
 * defaultParams is a fixed object into which the event value is merged.
 */
class SynthStream extends dryadic_1.Dryad {
    add(player) {
        return {
            run: (context, properties) => {
                const subscription = properties.stream.subscribe(event => {
                    // This assumes a Bacon event.
                    // Should validate that event.value is object
                    // assumes context has not been updated and is the same event
                    // use player.getContext()
                    this.handleEvent(event.value(), context, properties, player);
                });
                player.updateContext(context, { subscription });
            },
        };
    }
    commandsForEvent(event, context, properties) {
        const msgs = [];
        let updateContext;
        const nodeIDs = context.nodeIDs || {};
        const key = event.key ? String(event.key) : "undefined";
        switch (event.type) {
            case "noteOff": {
                // if no key then there is no way to shut off notes
                // other than sending to the group
                const nodeID = nodeIDs[key];
                if (nodeID) {
                    msgs.push(nodeFree(nodeID || -1));
                    // TODO: if synthDef hasGate else just free it
                    // msgs.push(nodeSet(nodeID, [event.gate || 'gate', 0]));
                    // remove from nodeIDs
                    updateContext = {
                        nodeIDs: lodash_1.default.omit(nodeIDs, [key]),
                    };
                }
                else {
                    throw new Error(`NodeID was not registered for event key ${key || "undefined"}`);
                }
                break;
            }
            default: {
                // noteOn
                const defaultParams = properties.defaultParams || {};
                const args = lodash_1.default.assign({ out: context.out || 0 }, defaultParams.args, event.args);
                const defName = event.defName || defaultParams.defName;
                // if ev.id then create a nodeID and store it
                // otherwise it is anonymous
                let nodeID = -1;
                if (key) {
                    nodeID = context.scserver.state.nextNodeID();
                    // store the nodeID
                    updateContext = {
                        nodeIDs: lodash_1.default.assign({}, nodeIDs, {
                            [key]: nodeID,
                        }),
                    };
                }
                const synth = synthNew(defName, nodeID, AddActions.TAIL, context.group, args);
                msgs.push(synth);
            }
        }
        return {
            scserver: {
                bundle: {
                    time: LATENCY,
                    packets: msgs,
                },
            },
            updateContext,
        };
    }
    handleEvent(event, context, properties, player) {
        player.callCommand(context.id, this.commandsForEvent(event, context, properties));
    }
    remove() {
        return {
            run: (context) => {
                if (context.subscription) {
                    if (lodash_1.default.isFunction(context.subscription)) {
                        // baconjs style
                        context.subscription();
                    }
                    else {
                        // Rx style
                        context.subscription.dispose();
                    }
                }
            },
        };
    }
    subgraph() {
        return new Group_1.default({}, [this]);
    }
}
exports.default = SynthStream;
//# sourceMappingURL=SynthStream.js.map