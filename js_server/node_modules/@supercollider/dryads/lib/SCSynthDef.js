"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const server_1 = require("@supercollider/server");
const dryadic_1 = require("dryadic");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const { defFree, defLoad, defRecv } = server_1.msg;
const fsp = fs_1.default.promises;
const StateKeys = {
    SYNTH_DEFS: "SYNTH_DEFS",
};
/**
 * Compile a SynthDef from sclang source code
 * or load a precompiled .scsyndef
 *
 * If compilation is required then it will insert SCLang as a parent if necessary.
 *
 * Note that the synthDefName is not known until after the source code is compiled.
 */
class SCSynthDef extends dryadic_1.Dryad {
    static fromSource(source) {
        return new SCSynthDef({
            source,
            watch: false,
        });
    }
    static fromFile(path) {
        return new SCSynthDef({
            compileFrom: path,
            watch: true,
        });
    }
    defaultProperties() {
        return { watch: false };
    }
    /**
     * If there is no SCLang in the parent context,
     * then this will wrap itself in an SCLang (language interpreter).
     */
    requireParent() {
        if (this.properties.source || this.properties.compileFrom) {
            return "SCLang";
        }
    }
    prepareForAdd() {
        // search context for a SynthDefCompiler, else create one with context.lang
        return {
            updateContext: (context, properties) => ({
                synthDef: this._prepareForAdd(context, properties),
            }),
            callOrder: "SELF_THEN_CHILDREN" /* SELF_THEN_CHILDREN */,
        };
    }
    async _prepareForAdd(context, properties) {
        if (properties.source) {
            const result = await this.compileSource(context, properties.source);
            await this._sendSynthDef(context, properties, result);
            return result;
        }
        if (properties.compileFrom) {
            const result = await this.compileFrom(context, properties.compileFrom);
            await this._sendSynthDef(context, properties, result);
            return result;
        }
        const lf = properties.loadFrom;
        if (lf) {
            // TODO: this is a bad assumption
            // Should allow to read .json metadata files and/or to set the name
            const result = {
                name: path_1.default.basename(lf, path_1.default.extname(lf)),
            };
            if (context.scserver) {
                await context.scserver.callAndResponse(defLoad(path_1.default.resolve(lf)));
            }
            return result;
        }
        throw new Error("Nothing specified for SCSynthDef: source|compileFrom|loadFrom Properties:" + JSON.stringify(properties));
    }
    async _sendSynthDef(context, properties, result) {
        // ! alters context
        // name bytes
        // synthDefName should be set for child context
        if (!context.scserver) {
            throw new Error("Missing scserver in context");
        }
        this.putSynthDef(context, result.name, result.synthDesc);
        // you need to use a setter
        context.synthDef = result;
        // context.synthDefName = result.name;
        const buffer = Buffer.from(result.bytes);
        const promises = [context.scserver.callAndResponse(defRecv(buffer))];
        if (properties.saveToDir) {
            promises.push(this._writeSynthDef(result.name, buffer, result.synthDesc, properties.saveToDir));
        }
        await Promise.all(promises);
        return result;
    }
    async _writeSynthDef(name, buffer, synthDesc, saveToDir) {
        const dir = path_1.default.resolve(saveToDir);
        const pathname = path_1.default.join(dir, name + ".scsyndef");
        await fsp.writeFile(pathname, buffer);
        const descpath = path_1.default.join(dir, name + ".json");
        await fsp.writeFile(descpath, JSON.stringify(synthDesc, null, 2));
    }
    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */
    async compileSource(context, sourceCode, pathName) {
        // add surrounding { } to any expressions that start with arg or |
        const autoBraced = /^ *arg|\|/.test(sourceCode) ? `{ ${sourceCode} }` : sourceCode;
        const wrappedCode = `{
      var def = { ${autoBraced} }.value.asSynthDef;
      (
        name: def.name,
        synthDesc: def.asSynthDesc.asJSON(),
        bytes: def.asBytes()
      )
    }.value;`;
        if (!context.sclang) {
            throw new Error(`Missing sclang in context: ${JSON.stringify(context)}`);
        }
        return context.sclang.interpret(wrappedCode, undefined, false, false, true).then((result) => {
            // JSONType
            return result;
        }, (error) => {
            error.annotate(`Failed to compile SynthDef  ${error.message} ${pathName || ""}`, {
                properties: this.properties,
                sourceCode,
            });
            return Promise.reject(error);
        });
    }
    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */
    async compileFrom(context, sourcePath) {
        // TODO: utf-8, no?
        const source = (await fsp.readFile(path_1.default.resolve(sourcePath))).toString("ascii");
        return this.compileSource(context, source, sourcePath);
    }
    add() {
        return {
            run: (context, properties) => {
                if (properties.compileFrom && properties.watch) {
                    // should use updater here
                    context._watcher = fs_1.default.watch(path_1.default.resolve(properties.compileFrom), () => {
                        if (properties.compileFrom) {
                            this.compileFrom(context, properties.compileFrom).then((result) => {
                                this._sendSynthDef(context, properties, result).catch(error => console.error(error));
                            });
                        }
                    });
                }
            },
        };
    }
    remove() {
        return {
            scserver: {
                // no need to do this if server has gone away
                msg: (context) => {
                    if (context.synthDef) {
                        return defFree(context.synthDef.name);
                    }
                },
            },
            run: (context) => {
                if (context._watcher) {
                    context._watcher.close();
                    delete context._watcher;
                }
            },
        };
    }
    putSynthDef(context, synthDefName, synthDesc) {
        context.scserver &&
            context.scserver.state.mutate(StateKeys.SYNTH_DEFS, state => {
                return state.set(synthDefName, synthDesc);
            });
    }
    /**
     * Return the value of this object, which is the synthDef: {name, bytes, synthDesc}
     * for use in /s_new.
     */
    value(context) {
        if (!context.synthDef) {
            throw new Error("No synthDef in context for SCSynthDef");
        }
        return context.synthDef;
    }
}
exports.default = SCSynthDef;
//# sourceMappingURL=SCSynthDef.js.map