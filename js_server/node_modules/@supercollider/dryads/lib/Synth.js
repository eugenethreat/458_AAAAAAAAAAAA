"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const server_1 = require("@supercollider/server");
const dryadic_1 = require("dryadic");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const SCSynthDef_1 = tslib_1.__importDefault(require("./SCSynthDef"));
const { AddActions, nodeFree, synthNew } = server_1.msg;
/**
 * Creates a synth on the server.
 *
 * Properties:
 * - def
 * - args
 */
class Synth extends dryadic_1.Dryad {
    /**
     * Make a Synth that will play the SynthDef compiled from sclang source code.
     *
     * source may be fully defined:
     *   `SynthDef("defName", { |out=0, freq=440| Out.ar(SinOsc.ar(freq)) });`
     * or more simply:
     *   `{|freq| SinOsc.ar(freq)}`
     * or even just:
     *    `|freq| SinOsc.ar(freq)`
     */
    static fromSource(source, args = {}) {
        return new Synth({ def: SCSynthDef_1.default.fromSource(source), args });
    }
    /**
     * Make a Synth that will play the SynthDef compiled from an *.scd source code file
     */
    static fromFile(path, args = {}) {
        return new Synth({ def: SCSynthDef_1.default.fromFile(path), args });
    }
    /**
     * If there is no SCServer in the parent context,
     * then this will wrap itself in an SCServer
     */
    requireParent() {
        return "SCServer";
    }
    prepareForAdd() {
        return {
            updateContext: context => ({
                nodeID: context.scserver.state.nextNodeID(),
            }),
        };
    }
    // synthDefName(context:object) : string {
    //   // The parent SCSynthDef publishes both .synthDef (object) and .synthDefName to context
    //   let name = _.isString(this.properties.def) ? this.properties.def : (context.synthDef && context.synthDef.name);
    //   if (!name) {
    //     throw new Error('No synthDefName supplied to Synth', context);
    //   }
    //   return name;
    // }
    add() {
        const defName = def => (typeof def === "string" ? def : def.name);
        return {
            scserver: {
                msg: (context, properties) => {
                    const args = lodash_1.default.mapValues(properties.args, (value, key) => this._checkOscType(value, key, context.id));
                    // if out is not set in args and out is in synthdef
                    // then set it from context
                    // TODO: check that synthDef has an arg named out
                    if (lodash_1.default.isUndefined(args.out) && !lodash_1.default.isUndefined(context.out)) {
                        args.out = context.out;
                    }
                    const dn = this._checkOscType(defName(properties.def), "def.name", context.id);
                    return synthNew(dn, context.nodeID, AddActions.TAIL, context.group, args);
                },
            },
            run: (context, properties) => {
                return server_1.whenNodeGo(context.scserver, context.id, context.nodeID || -1).then(nodeID => {
                    // TODO: call a method instead so its testable
                    server_1.updateNodeState(context.scserver, nodeID, {
                        synthDef: defName(properties.def),
                    });
                    return nodeID;
                });
            },
        };
    }
    remove() {
        return {
            scserver: {
                msg: (context) => nodeFree(context.nodeID || -1),
            },
            run: (context) => server_1.whenNodeEnd(context.scserver, context.id, context.nodeID || -1),
        };
    }
    _checkOscType(v, key, id) {
        switch (typeof v) {
            case "number":
            case "string":
                // case 'Buffer':
                return v;
            default:
                throw new Error(`Invalid OSC type for Synth ${key}: [${typeof v}: ${v}] @ ${id}`);
        }
    }
}
exports.default = Synth;
//# sourceMappingURL=Synth.js.map