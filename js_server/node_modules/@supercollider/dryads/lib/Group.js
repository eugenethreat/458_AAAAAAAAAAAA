"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dryadic_1 = require("dryadic");
const server_1 = require("@supercollider/server");
const { AddActions, groupNew, nodeFree } = server_1.msg;
/**
 * Creates a group on the server; sets .group in context for its children,
 * so any Synths or Groups will be spawned inside this group.
 */
class Group extends dryadic_1.Dryad {
    /**
     * If there is no SCServer in the parent context,
     * then this will wrap itself in an SCServer
     */
    requireParent() {
        return "SCServer";
    }
    prepareForAdd() {
        return {
            callOrder: "SELF_THEN_CHILDREN" /* SELF_THEN_CHILDREN */,
            updateContext: (context /*, properties*/) => {
                const nodeID = context.scserver.state.nextNodeID();
                return {
                    nodeID,
                    // TODO: but this overwrites my own group !
                    // what if parent is a group ?
                    // I need to create this group within that group
                    // This should just be childContext,
                    // but that is only called when creating the tree.
                    group: nodeID,
                    // for now, save it to parentGroup
                    parentGroup: context.group || 0,
                };
            },
        };
    }
    add() {
        return {
            scserver: {
                msg: (context) => groupNew(context.nodeID, AddActions.TAIL, context.parentGroup),
            },
            run: (context) => server_1.whenNodeGo(context.scserver, context.id, context.nodeID),
        };
    }
    remove() {
        return {
            scserver: {
                // children do not have to free their nodes
                // as they get freed by freeing this parent
                // so remove for children needs to communicate that somehow
                // but buffers and busses do need to free
                msg: (context) => nodeFree(context.nodeID),
            },
            run: (context) => server_1.whenNodeEnd(context.scserver, context.id, context.nodeID),
        };
    }
}
exports.default = Group;
//# sourceMappingURL=Group.js.map