"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffers_1 = require("./buffers");
const timetags_1 = require("./timetags");
const oscTypeReaders = {
    s: {
        type: "string",
        read: function (buffer) {
            return buffer.readString();
        },
        toArg: function (value) {
            return buffers_1.toOscString(value);
        },
    },
    i: {
        type: "integer",
        read: function (buffer) {
            return buffer.readInt32();
        },
        toArg: function (value) {
            return buffers_1.toIntegerBuffer(value);
        },
    },
    // does anything send this in a message?
    // sclang supports this inbound but the scsynth never sends it
    // t: {
    //   type: "timetag",
    //   read: function(buffer: BufferReader): NTPTimeTag {
    //     return buffer.readTimetag();
    //   },
    //   toArg: function(value: OSCTimeType): Buffer {
    //     return toTimetagBuffer(value);
    //   },
    // },
    f: {
        type: "float",
        read: function (buffer) {
            return buffer.readFloat32();
        },
        toArg: function (value) {
            return buffers_1.toFloatBuffer(value);
        },
    },
    d: {
        type: "double",
        read: function (buffer) {
            return buffer.readDouble();
        },
        toArg: function (value) {
            return buffers_1.toDoubleBuffer(value);
        },
    },
    b: {
        type: "blob",
        read: function (buffer) {
            return buffer.readBuffer();
        },
        toArg: function (value) {
            // An int32 size count, followed by that many 8-bit bytes of arbitrary binary data, followed by 0-3 additional zero bytes to make the total number of bits a multiple of 32.
            const size = buffers_1.toIntegerBuffer(value.length);
            return Buffer.concat([size, value]);
        },
    },
    T: {
        type: "true",
        read: function (buffer) {
            return true;
        },
        toArg: function (value) {
            return Buffer.alloc(0);
        },
    },
    F: {
        type: "false",
        read: function (buffer) {
            return false;
        },
        toArg: function (value) {
            return Buffer.alloc(0);
        },
    },
    N: {
        type: "null",
        read: function (buffer) {
            return null;
        },
        toArg: function (value) {
            return Buffer.alloc(0);
        },
    },
};
// reverse lookup dict
const oscTypeCodesForType = (function () {
    const r = {};
    Object.entries(oscTypeReaders).forEach(([key, value]) => {
        r[value.type] = key;
    });
    return r;
})();
function typeCodeForTypeString(typeString) {
    return oscTypeCodesForType[typeString];
}
function typeStringForTypeCode(typeCode) {
    return oscTypeReaders[typeCode].type;
}
function typeCodeForArg(arg) {
    switch (typeof arg) {
        case "string":
            return "s";
        case "number":
            // All numbers defaults to float
            return "f";
        case "boolean":
            return arg ? "T" : "F";
        default:
            if (arg === null) {
                return "N";
            }
            if (Buffer.isBuffer(arg)) {
                return "b";
            }
            throw new Error(`Unsupported OSC Type ${typeof arg} ${arg}`);
    }
}
function oscTypeAsBuffer(value, type) {
    const osctype = typeCodeForTypeString(type);
    if (osctype) {
        // could write directly to a buffer
        return oscTypeReaders[osctype].toArg(value);
    }
    else {
        throw new Error(`OSC Cannot send unsupported type: ${type}`);
    }
}
function readOSCMessage(buffer) {
    const address = buffer.readString();
    if (buffer.ended()) {
        return {
            address: address,
            args: [],
            oscType: "message",
        };
    }
    const types = buffer.readString();
    // characters indicate the types of each argument
    const args = [];
    for (let index = 0; index < types.length; index++) {
        const typeChar = types[index];
        if (index === 0) {
            if (typeChar !== ",") {
                throw new Error("Argument lists must begin with ,");
            }
        }
        else {
            // read type
            const tr = oscTypeReaders[typeChar];
            if (!tr) {
                throw new Error(`Unhandled OSC type ${typeChar}`);
            }
            // could return a timetag [number, number]
            // but actually wouldn't
            const value = tr.read(buffer);
            args.push(value);
        }
    }
    return {
        address: address,
        args,
        oscType: "message",
    };
}
function readOSCBundle(buffer) {
    const bundleTag = buffer.readString(false);
    if (bundleTag !== "#bundle") {
        throw new Error("osc-bundles must begin with #bundle");
    }
    else {
        // consume it
        buffer.readString(true);
    }
    const timetag = buffer.readTimetag();
    const convertedElems = readBundleElements(buffer);
    return {
        timetag: timetag,
        // packets?
        elements: convertedElems,
        oscType: "bundle",
    };
}
function readOSCPacket(buffer) {
    if (isOscBundleBuffer(buffer)) {
        return readOSCBundle(buffer);
    }
    else {
        return readOSCMessage(buffer);
    }
}
// const getArrayArg = (arg: OscType): Array<OscType> | null => {
//   if (Array.isArray(arg)) {
//     return arg;
//   }
//   return null;
// };
function buildMessageArgs(argList) {
    let oscTypes = "";
    const oscArgs = [];
    argList.forEach(arg => {
        const typeCode = typeCodeForArg(arg);
        const buff = oscTypeAsBuffer(arg, typeStringForTypeCode(typeCode));
        oscArgs.push(buff);
        oscTypes += typeCode;
    });
    return [oscTypes, oscArgs];
}
function packMessage(message) {
    const address = message.address;
    const args = message.args || [];
    const [oscTypes, oscArgs] = buildMessageArgs(args);
    const buffer = new buffers_1.BufferWriter();
    buffer.writeString(address);
    buffer.writeString("," + oscTypes);
    oscArgs.forEach(oa => {
        buffer.insertBuffer(oa);
    });
    return buffer.crop();
}
exports.packMessage = packMessage;
function packBundle(bundle) {
    const buffer = new buffers_1.BufferWriter();
    buffer.writeString("#bundle");
    buffer.writeTimetag(timetags_1.asNTPTimeTag(bundle.timetag));
    bundle.elements.forEach(elem => {
        const buff = packElement(elem);
        buffer.writeBuffer(buff);
    });
    return buffer.crop();
}
exports.packBundle = packBundle;
function packElement(bundleOrMessage) {
    switch (bundleOrMessage.oscType) {
        case "bundle":
            return packBundle(bundleOrMessage);
        case "message":
            return packMessage(bundleOrMessage);
        default:
            if ("timetag" in bundleOrMessage) {
                return packBundle(bundleOrMessage);
            }
            if ("address" in bundleOrMessage) {
                return packMessage(bundleOrMessage);
            }
            throw new Error(`Unmatched oscType (message|bundle) ${JSON.stringify(bundleOrMessage)}`);
    }
}
function isOscBundleBuffer(buffer) {
    // read string at but do not advance cursor
    return buffer.readString(false) === "#bundle";
}
/**
 * map each item in buffer with a function
 */
function readBundleElements(buffer) {
    const results = [];
    while (!buffer.ended()) {
        // is it readBuffer? that implies it has a start size
        const packetBuffer = new buffers_1.BufferReader(buffer.readBuffer());
        if (!packetBuffer.ended()) {
            const elem = readOSCPacket(packetBuffer);
            // what if it doesn't advance offset ?
            if (elem) {
                results.push(elem);
            }
        }
    }
    return results;
}
/**
 * Unpacks either an OSCMessage or OSCBundle from an OSC Packet
 * It's a bundle if it starts with `#bundle`
 */
function unpack(buffer) {
    return readOSCPacket(new buffers_1.BufferReader(buffer));
}
exports.unpack = unpack;
function unpackMessage(buffer) {
    return readOSCMessage(new buffers_1.BufferReader(buffer));
}
exports.unpackMessage = unpackMessage;
function unpackBundle(buffer) {
    return readOSCBundle(new buffers_1.BufferReader(buffer));
}
exports.unpackBundle = unpackBundle;
/**
 * Encodes an OSCMessage or OSCBundle to a Buffer
 */
function pack(msgOrBundle) {
    return packElement(msgOrBundle);
}
exports.pack = pack;
//# sourceMappingURL=packing.js.map