"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Convert a MIDI note (1..127) to frequency.
 */
function midiToFreq(midiNote) {
    return 440.0 * Math.pow(2, (midiNote - 69.0) / 12.0);
}
exports.midiToFreq = midiToFreq;
/**
 * Convert frequency to MIDI note (1..127).
 */
function freqToMidi(freq) {
    const mult = Math.log(freq / 400.0) / Math.log(2);
    return Math.round(12.0 * mult + 69);
}
exports.freqToMidi = freqToMidi;
/**
 * Map a number from linear min/max to min/max.
 */
function linToLin(inMin, inMax, outMin, outMax, value) {
    if (value <= inMin) {
        return outMin;
    }
    if (value >= inMax) {
        return outMax;
    }
    return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
}
exports.linToLin = linToLin;
/**
 * Map a number from linear min/max to exponential min/max.
 */
function linToExp(inMin, inMax, outMin, outMax, value) {
    if (value <= inMin) {
        return outMin;
    }
    if (value >= inMax) {
        return outMax;
    }
    return Math.pow(outMax / outMin, (value - inMin) / (inMax - inMin)) * outMin;
}
exports.linToExp = linToExp;
/**
 * Map a number from exponential min/max to linear min/max.
 */
function expToLin(inMin, inMax, outMin, outMax, value) {
    if (value <= inMin) {
        return outMin;
    }
    if (value >= inMax) {
        return outMax;
    }
    return (Math.pow(outMax / outMin, Math.log(value / inMin) / Math.log(inMax / inMin)) * outMin);
}
exports.expToLin = expToLin;
/**
 * Map an amplitude value (usually 0..1) to dB.
 */
function ampToDb(amp) {
    return Math.log10(amp) * 20.0;
}
exports.ampToDb = ampToDb;
/**
 * Map dB to an amplitude value that can be used as a multiplier.
 */
function dbToAmp(db) {
    return Math.pow(10.0, db * 0.05);
}
exports.dbToAmp = dbToAmp;
/**
 * Returns a function that maps 0..1 input to the spec's minval..maxval with a linear curve.
 */
function linear(spec) {
    const range = spec.maxval - spec.minval;
    return function (value) {
        return value * range + spec.minval;
    };
}
exports.linear = linear;
/**
 * Returns a function that maps 0..1 input to the spec's minval..maxval with an exponential curve. minval/maxval must not have oppositive signs -- ie. the output range must not cross zero.
 */
function exp(spec) {
    const ratio = spec.maxval / spec.minval;
    return function (value) {
        return Math.pow(ratio, value) * spec.minval;
    };
}
exports.exp = exp;
/**
 * Returns dB mapping function (DbFaderWarp)
 */
function dB(spec) {
    const minval = dbToAmp(spec.minval);
    const range = dbToAmp(spec.maxval) - minval;
    return function (value) {
        return ampToDb(Math.pow(value, 2) * range - minval);
    };
}
exports.dB = dB;
/**
 * Returns amp mapping function (FaderWarp)
 */
function fader(spec) {
    const range = spec.maxval - spec.minval;
    return function (value) {
        return Math.pow(value, 2) * range - spec.minval;
    };
}
exports.fader = fader;
/**
 * Returns inverse of linear mapping function
 */
function unmapLinear(spec) {
    const range = spec.maxval - spec.minval;
    return function (value) {
        return (value - spec.minval) / range;
    };
}
exports.unmapLinear = unmapLinear;
/**
 * Returns inverse of exponential mapping function
 */
function unmapExp(spec) {
    const ratio = Math.log(spec.maxval / spec.minval);
    return function (value) {
        return Math.log(value / spec.minval) / ratio;
    };
}
exports.unmapExp = unmapExp;
/**
 * Returns inverse of dB mapping function (DbFaderWarp)
 */
function unmapDb(spec) {
    const minval = dbToAmp(spec.minval);
    const range = dbToAmp(spec.maxval) - minval;
    return function (value) {
        return (dbToAmp(value) - minval) / Math.sqrt(range);
    };
}
exports.unmapDb = unmapDb;
/**
 * Returns inverse of amp mapping function (FaderWarp)
 */
function unmapFader(spec) {
    const range = spec.maxval - spec.minval;
    return function (value) {
        return Math.sqrt((value - spec.minval) / range);
    };
}
exports.unmapFader = unmapFader;
/**
 * Returns the inverse mapping function for a spec, using the curve
 * as defined by spec.warp
 */
function unmapWithSpec(value, spec) {
    switch (spec.warp) {
        case "linear":
        case "lin":
            return unmapLinear(spec)(value);
        case "exp":
        case "exponential":
            return unmapExp(spec)(value);
        case "amp":
            return unmapFader(spec)(value);
        case "db":
            return unmapDb(spec)(value);
        default:
            throw new Error("Warp unknown or not yet implemented" + spec.warp);
    }
}
exports.unmapWithSpec = unmapWithSpec;
/**
 * Returns the mapping function for a spec, using the curve
 * as defined by spec.warp
 */
function mapWithSpec(value, spec) {
    switch (spec.warp) {
        case "linear":
        case "lin":
            return linear(spec)(value);
        case "exp":
        case "exponential":
            return exp(spec)(value);
        case "amp":
            return fader(spec)(value);
        case "db":
            return dB(spec)(value);
        default:
            throw new Error("Warp unknown or not yet implemented" + spec.warp);
    }
}
exports.mapWithSpec = mapWithSpec;
//# sourceMappingURL=mapping.js.map