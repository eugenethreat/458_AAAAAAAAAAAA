"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const rx_1 = require("rx");
const utils_1 = require("../osc/utils");
const osc_1 = require("@supercollider/osc");
/**
 * Owned by the Server, this is an object that you call .msg or .bundle on
 * to send OSC.
 *
 * The Server subscribes to this and does the actual sending.
 * You may also subscribe to this for debugging, logging or entertainment purposes.
 */
class SendOSC extends events_1.EventEmitter {
    msg(message) {
        this.emit("msg", utils_1.makeMessage(message));
    }
    /**
     * bundle
     *
     * Note that in SuperCollider language a number is interpreted
     * as relative seconds from 'now'; here is is interpreted as a
     * unix timestamp. See deltaTimeTag
     *
     * @param {null|Number|Array|Date} time
     *   - null: now, immediately
     *   - Number: if less than 10000 then it is interpreted
     *       as number of seconds from now.
     *       It it is larger then it is interpreted as a unix timestamp in seconds
     *   - Array: `[secondsSince1900Jan1, fractionalSeconds]`
     *   - Date
     * @param {Array} packets - osc messages as `[address, arg1, ...argN]`
     *                        or sub bundles as `[{timetag: , packets: }, ...]`
     */
    bundle(time, packets) {
        if (typeof time === "number" && time < 10000) {
            time = osc_1.deltaTimeTag(time);
        }
        this.emit("bundle", utils_1.makeBundle(time, packets));
    }
    /**
     * Make NTP timetag array relative to the current time.
     *
     * @example:
     *
     *    server.send.bundle(server.send.deltaTimeTag(1.0), [ ... msgs ]);
     *
     * @param {Number} delta
     * @param {Date} now - optional, default new Date
     */
    deltaTimeTag(delta, now) {
        // was just [number]
        return osc_1.deltaTimeTag(delta, now);
    }
    /**
     * Subscribe to monitor OSC messages and bundles sent.
     *
     * Events are: `{type: msg|bundle: payload: Array}`
     *
     * @returns {Rx.Disposable} - `thing.dispose();` to unsubscribe
     */
    subscribe(onNext, onError, onComplete) {
        const msgs = rx_1.Observable.fromEvent(this, "msg", msg => {
            return {
                type: "msg",
                payload: msg,
            };
        });
        const bundles = rx_1.Observable.fromEvent(this, "bundle", bundle => {
            return {
                type: "bundle",
                payload: bundle,
            };
        });
        const combo = msgs.merge(bundles);
        return combo.subscribe(onNext, onError, onComplete);
    }
}
exports.default = SendOSC;
//# sourceMappingURL=SendOSC.js.map