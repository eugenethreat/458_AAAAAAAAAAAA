"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const server_1 = require("@supercollider/server");
const sclang_1 = require("./sclang");
/**
 * Utility class to compile SynthDefs either from source code or by loading a path.
 *
 * Stores metadata, watches path for changes and can resend on change.
 * Can write compiled synthDefs to .scsyndef
 *
 * @ member of lang
 */
class SynthDefCompiler {
    constructor(lang) {
        this.lang = lang;
        this.store = new Map();
    }
    async boot() {
        if (!this.lang) {
            this.lang = await sclang_1.boot();
        }
        return this.lang;
    }
    /**
     * Returns an object with each compiled synthdef
     * as a SynthDefResultType.
     */
    async compile(defs) {
        const results = {};
        const compiling = lodash_1.default.map(defs, async (request, defName) => {
            const result = await this._compileOne(defName, request);
            results[defName] = result;
        });
        await Promise.all(compiling);
        return results;
    }
    /**
     * Compile SynthDefs and send them to the server.
     *
     * @returns a Promise for {defName: SynthDefResult, ...}
     */
    async compileAndSend(defs, server) {
        // compile...
        const compiledDefs = await this.compile(defs);
        // send...
        const commands = lodash_1.default.map(compiledDefs, (compileResult, name) => this.sendCommand(name));
        await Promise.all(commands.map(cmd => server.callAndResponse(cmd)));
        return compiledDefs;
    }
    set(defName, data) {
        this.store.set(defName, data);
        return data;
    }
    get(defName) {
        return this.store.get(defName);
    }
    allSendCommands() {
        const commands = [];
        this.store.forEach((value, defName) => {
            commands.push(this.sendCommand(defName));
        });
        return commands;
    }
    sendCommand(defName) {
        const data = this.get(defName);
        if (!data) {
            throw new Error(`SynthDef not in store: ${defName}`);
        }
        const buffer = Buffer.from(data.bytes);
        return server_1.msg.defRecv(buffer);
    }
    // sendAll(server) {
    //   return Promise.all(
    //     this.store.keys().map((defName) => this.send(defName, server))
    //   );
    // }
    //
    // send(defName:string, server:Server) {
    //   let data = this.get(defName);
    //   let buffer = new Buffer(data.bytes);
    //   let promises = [
    //     context.scserver.callAndResponse(defRecv(buffer))
    //   ];
    //
    // }
    async _compileOne(defName, spec) {
        // path or source
        let result;
        if ("source" in spec) {
            result = await this.compileSource(spec.source);
        }
        else if ("path" in spec) {
            result = await this.compilePath(spec.path);
        }
        else {
            throw new Error(`Spec to SynthDefCompiler not recognized ${defName} ${JSON.stringify(spec)}`);
        }
        this.set(defName, result);
        return result;
        // TODO: if watch then add a watcher
    }
    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */
    async compileSource(sourceCode, pathName) {
        const wrappedCode = `{
      var def = { ${sourceCode} }.value.asSynthDef;
      (
        name: def.name,
        synthDesc: def.asSynthDesc.asJSON(),
        bytes: def.asBytes()
      )
    }.value;`;
        if (this.lang) {
            try {
                const result = await this.lang.interpret(wrappedCode, undefined, false, false, true);
                // force casting it to the expected type
                return result;
            }
            catch (error) {
                error.annotate(`Failed to compile SynthDef  ${error.message} ${pathName || ""}`, {
                    sourceCode,
                });
                throw error;
            }
        }
        throw new Error(`sclang interpreter is not present: ${this.lang}`);
    }
    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */
    compilePath(sourcePath) {
        return new Promise((resolve, reject) => {
            fs_1.default.readFile(path_1.default.resolve(sourcePath), (err, fileBuf) => {
                if (err) {
                    reject(err);
                }
                else {
                    // is it really just ascii ?
                    this.compileSource(fileBuf.toString("ascii"), sourcePath).then(resolve, reject);
                }
            });
        });
    }
}
exports.default = SynthDefCompiler;
//# sourceMappingURL=SynthDefCompiler.js.map