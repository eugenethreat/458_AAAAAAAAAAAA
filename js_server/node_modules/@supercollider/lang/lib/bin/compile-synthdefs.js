#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint no-console: 0 */
const path_1 = tslib_1.__importDefault(require("path"));
const index_1 = require("../index");
const commander_1 = tslib_1.__importDefault(require("commander"));
const fs_1 = require("fs");
/* eslint @typescript-eslint/no-var-requires: 0 */
const pkg = require(path_1.default.join(__dirname, "../../package.json"));
const help = [];
commander_1.default.on("--help", function () {
    help.forEach(function (line) {
        console.info("    " + line);
    });
});
commander_1.default.version(pkg.version);
commander_1.default.usage("<source-files> <destination>");
commander_1.default.parse(process.argv);
if (commander_1.default.args.length < 2) {
    commander_1.default.help();
}
// the shell will expand any globs
const lastArg = commander_1.default.args[commander_1.default.args.length - 1];
const dest = path_1.default.resolve(lastArg);
const sources = commander_1.default.args.map(function (p) {
    return path_1.default.resolve(p);
});
// an invalid source glob will not be expanded
// and resolve will just return it as is.
// Should probably warn and skip
// and warn and skip synthdefs/ rather than synthdefs/*
async function main() {
    const sclang = await index_1.boot({ stdin: false, debug: false });
    function removeAll() {
        return sclang.interpret("SynthDescLib.default.synthDescs.removeAll();");
    }
    function interpretFiles() {
        return Promise.all(sources.map(src => {
            return sclang.executeFile(src).catch(error => {
                console.error(`${src} ${error}`, error);
                throw error;
            });
        }));
    }
    // returns SynthDescs as a JSON-ready dict
    function writeDefs() {
        return sclang.interpret(`
      var descs = Dictionary.new;
      SynthDescLib.default.synthDescs
        .keysValuesDo({ arg defName, synthDesc;
          synthDesc.def.writeDefFile("` +
            dest +
            `");
          descs[defName] = synthDesc.asJSON();
        });
      descs
      `);
    }
    function writeDescs(descs) {
        return fs_1.promises.writeFile(path_1.default.join(dest, "synthDefs.json"), JSON.stringify(descs, null, 2));
    }
    await removeAll();
    await interpretFiles();
    const descs = await writeDefs();
    await writeDescs(descs);
}
main().then(() => process.exit(0), (error) => {
    console.error(error);
    process.exit(1);
});
//# sourceMappingURL=compile-synthdefs.js.map