import CommandMiddleware from "./CommandMiddleware";
import CommandNode from "./CommandNode";
import Dryad, { DryadType } from "./Dryad";
import DryadTree, { DebugState } from "./DryadTree";
import { Command, Context, HyperScript, Layer } from "./types";
interface ClassTable {
    [className: string]: DryadType;
}
export declare type GetClassFn = (className: string) => DryadType;
/**
 * Manages play/stop/update for a Dryad tree.
 *
 * A Dryad has no state or functionality until it is played
 * by a DryadPlayer. A Dryad can be played more than once at
 * the same time by creating more DryadPlayers.
 *
 * The DryadPlayer also holds the layers and command middleware
 * which execute the functionality that the Dryads specify.
 */
export default class DryadPlayer {
    middleware: CommandMiddleware;
    classes: ClassTable;
    tree?: DryadTree;
    log: Console;
    _errorLogger: Function;
    constructor(rootDryad?: Dryad | null, layers?: Layer[], rootContext?: Context);
    /**
     * Set a new tree.
     *
     * Behavior while already playing is not yet defined.
     *
     * @param {Dryad} dryad
     */
    setRoot(dryad: Dryad | Dryad[] | null, rootContext?: Context): void;
    /**
     * Convert hyperscript graph to Dryad objects with registered classes
     *
     * @param {Object} hgraph - JSON style object
     * @returns {Dryad}
     */
    h(hgraph: Dryad | Dryad[]): Dryad;
    /**
     * Add a layer of functionality by registering Dryad classes and command middleware.
     *
     * @param layer - .classes is a list of Dryad classes, .middleware is a list of middleware functions
     */
    use(layer: Layer): DryadPlayer;
    /**
     * Register a Dryad class so it can be located when used in hyperscript.
     * Also needed if a class uses requireParent()
     */
    addClass(dryadClass: DryadType): void;
    /**
     * Lookup Dryad class by name.
     *
     * Used by hyperscript and requireParent, this requires
     * that layers and their classes were registered and any custom
     * classes that you right are registered. If you aren't using
     * hyperscript then you don't need to register your class.
     *
     * @param className - case-insensitive
     */
    getClass: GetClassFn;
    /**
     * Prepare Dryads in document for play.
     *
     * This allocates resources and performs any time consuming async work
     * required before the Dryads may play.
     *
     * Prepare commands may fail by rejecting their Promises.
     * Unable to allocate resource, required executables do not exist etc.
     *
     * .play commands should not fail
     *
     */
    prepare(): Promise<DryadPlayer>;
    /**
     * Prepares and plays the current document.
     *
     * Optionally updates to a new document.
     *
     * @returns {Promise} - that resolves to `this`
     */
    play(dryad?: Dryad): Promise<DryadPlayer>;
    /**
     * @returns {Promise} - that resolves to `this`
     */
    stop(): Promise<DryadPlayer>;
    _collectCommands(commandName: string): CommandNode;
    /**
     * Collect commands and call for a transition: add|remove|prepareForAdd
     */
    call(stateTransitionName: string): Promise<DryadPlayer>;
    /**
     * Execute a command tree using middleware.
     */
    _call(commandTree: CommandNode, stateTransitionName: string): Promise<void>;
    /**
     * Execute a single command object for a single node using middleware
     * outside the prepareForAdd/add/remove full tree command execution routine.
     *
     * This can be called out of band from a Dryad's add/remove method
     *
     * Its for commands that need to be executed during runtime
     * in response to events, streams etc.
     * eg. spawning synths from an incoming stream of data.
     */
    callCommand(nodeId: string, command: Command): Promise<void>;
    /**
     * updateContext - Allow a Dryad to update its own context.
     *
     * This can be called during runtime by event handlers,
     * updates via stream etc. when you need to save new values into the context
     * outside of the add/remove/update functions.
     *
     * Contexts are immutable - this returns a new context object.
     *
     * @param  {Object} context to update
     * @param  {Object} update  updated variables
     * @return {Object}         new context object
     */
    updateContext(context: Context, update: Context): Context;
    /**
     * Get a representation of current state of the tree.
     * Contains add|remove|prepared and may hold errors.
     */
    getDebugState(): DebugState;
    /**
     * Get hyperscript representation of current (expanded) play graph
     */
    getPlayGraph(): HyperScript | undefined;
    dump(): void;
}
export {};
//# sourceMappingURL=DryadPlayer.d.ts.map