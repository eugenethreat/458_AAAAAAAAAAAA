"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const isArray_1 = tslib_1.__importDefault(require("lodash/isArray"));
const isObject_1 = tslib_1.__importDefault(require("lodash/isObject"));
const isString_1 = tslib_1.__importDefault(require("lodash/isString"));
const mapValues_1 = tslib_1.__importDefault(require("lodash/mapValues"));
/**
 * Convert a JSON object into a tree of instantiated Dryads.
 *
 * A Domain-specific language for easily creating Dryad trees
 * a la: https://github.com/Raynos/virtual-hyperscript
 *
 * This is used for sending tree documents from remote clients,
 * and for writing dryadic documents in JSON form without having to
 * import classes and construct trees filled with `new Object()` etc.
 *
 * className, properties:
 * ['synth', {freq: 440}]

 * className, properties, children:
 * ['audiobus', {numChannels: 2}, [
 *   ['synth', {defName: 'saw', args: {freq: 440}]
 * ]]

 * If there are only 2 items and the second is an Array (not Object),
 * then parse it as:
 *
 * className, children:
 *
 *  ['group', [
 *    ['synth', {freq: 440}]
 *  ]]
 *
 * If a property value is of the form [string, object] or [string, object, array] then assume it is
 * a dryad.
 *
 * ['synth', {
 *    'freq': ['synth', {'defName': 'lfo', 'freq': 0.3}]
 * }]
 *
 * @param {Array|Dryad} root - The Array is the top level (root) dryad form.
 *                           If a Dryad is supplied then no conversion is needed so it is returned immediately.
 * @param {Function} lookupClassByNameFn
 *        This function is provided by the DryadPlayer and converts strings into
 *        Dryad classes. It should throw an error if no Dryad class exists by that name.
 * @returns {Dryad} - the root Dryad
 */
function hyperscript(root, lookupClassByNameFn) {
    if (!root) {
        die(root, "Got null|undefined.");
    }
    // if the thing implements isDryad then the answer must be yes.
    if (root.isDryad) {
        return root;
    }
    if (!isArray_1.default(root)) {
        die(root, "Expected Array.");
    }
    // const [tag, properties, children] = root;
    const tag = root[0];
    let properties = root[1];
    let children = root[2];
    if (!tag) {
        die(root, "Null tag");
    }
    if (!(isString_1.default(tag) || tag.isDryadSubclass)) {
        die(root, "Expected tag to be string");
    }
    if (children) {
        if (!isObject_1.default(properties)) {
            die(root, "Expected properties to be an Object");
        }
        if (!isArray_1.default(children)) {
            die(root, "Expected children to be an Array");
        }
    }
    else {
        // If 2nd arg is an array then it is the children and there are no properties.
        if (isArray_1.default(properties)) {
            children = properties;
            properties = {};
        }
        else {
            if (properties && !isObject_1.default(properties)) {
                die(root, "Expected properties to be an Object");
            }
        }
    }
    // Convert any property value that looks like a hyperscript form to a Dryad
    properties = mapValues_1.default(properties || {}, value => isDryadForm(value) ? hyperscript(value, lookupClassByNameFn) : value);
    // Convert children
    const childNodes = (children || []).map(child => hyperscript(child, lookupClassByNameFn));
    // If the thing implements isDryadSubclass then the answer must be yes.
    // its a static method on Dryad
    const DryadClass = tag.isDryadSubclass ? tag : lookupClassByNameFn(tag);
    return new DryadClass(properties, childNodes);
}
exports.default = hyperscript;
function isDryadForm(value) {
    return isArray_1.default(value) && value.length <= 3 && isString_1.default(value[0]) && isObject_1.default(value[1]);
}
function die(root, message) {
    throw new Error(`Bad argument to hyperscript: [${typeof root}] ${root} ${message}`);
}
//# sourceMappingURL=hyperscript.js.map