import CommandNode from "./CommandNode";
import Dryad from "./Dryad";
import DryadPlayer, { GetClassFn } from "./DryadPlayer";
import { Context, Command, Properties, HyperScript } from "./types";
interface Memo {
    seenTypes?: string[];
    skipRequireParentOf?: Dryad;
    skipSubgraphOf?: Dryad;
}
export declare type DebugState = Record<string, any>;
declare type WalkFn = (node: TreeNode, dryad: Dryad, context: Context) => void;
/**
 * Manages the tree structure, contexts for nodes,
 * utilities to walk the tree, collect commands and
 * call command middleware.
 */
export default class DryadTree {
    root?: Dryad;
    tree?: TreeNode;
    dryads: {
        [id: string]: Dryad;
    };
    contexts: {
        [id: string]: Context;
    };
    getClass?: GetClassFn;
    rootContext: Context;
    nodeLookUp: Map<string, TreeNode>;
    /**
     * @param {Dryad} root
     * @param {Function} getClass - lookup function
     */
    constructor(root: Dryad, getClass?: GetClassFn, rootContext?: Context);
    /**
     * Depth first traversal of the Dryad tree
     *
     * The function is given arguments:
     *   node {id type children}
     *   Dryad
     *   context
     *   memo
     *
     * @param {Function} fn - called with (treeNode, dryad, context)
     * @param {TreeNode} node - starting node, defaults to the root
     * @param {Object} memo - for usage during recursion
     */
    walk(fn: WalkFn, node?: TreeNode, memo?: Memo): Memo;
    /**
     * Collect a tree of command objects from each node for a given method.
     * eg. 'add' 'remove' 'prepareForAdd'
     *
     * @param {String} stateTransitionName
     * @param {TreeNode} node - default is the root
     * @returns {CommandNode}
     */
    collectCommands(stateTransitionName: string, node: TreeNode, player: DryadPlayer): CommandNode;
    /**
     * Construct a command tree for a single commandObject to be executed
     * with a single node's context.
     *
     * This is for runtime execution of commands,
     * called from streams and async processes initiated during Dryad's .add()
     */
    makeCommandTree(nodeId: string, commands: Command): CommandNode;
    /**
     * For any properties that are functions, call them with context to get the 'value'.
     * These converted/resolved values are passed into the commands at prepareForAdd/add etc.
     */
    dryadProperties(nodeId: string): Properties;
    /**
     * Update a Dryad's context.
     *
     * @param {String} dryadId
     * @param {Object} update - values to assign into context
     * @returns {Object} context
     */
    updateContext(dryadId: string, update: Context): Context;
    getContext(dryadId: string): Context;
    /**
     * Get a representation of current state of the tree.
     * Contains add|remove|prepared and may hold errors.
     */
    getDebugState(): DebugState;
    /**
     * Return the current play graph as a hyperscript document.
     * Useful for testing and debugging.
     */
    hyperscript(): HyperScript | undefined;
    /**
     * Create and return initial context for a Dryad.
     *
     * Each context has the parent's context as its prototype,
     * so parent values are visible to children.
     *
     * @returns {Object}
     */
    _createContext(dryad: Dryad, dryadId: string, parentId?: string, rootContext?: Context): Context;
    /**
     * Creates the expanded play graph as a tree of TreeNodes.
     *
     * It is called initially with the root Dryad, then recursively for each child down the tree.
     *
     * - Generates ids for each Dryad
     * - Creates a context for each, storing in this.contexts
     *
     * Each node in the tree contains a TreeNode
     *
     * Dryad classes may use requireParent() and subgraph() to replace themselves
     * with a different graph.
     *
     * So this tree is not a direct mapping of the input graph, it is the expanded play graph.
     *
     * This method calls itself recursively for children.
     *
     * @param {Dryad} dryad
     * @param {String} parentId
     * @param {Integer} childIndex
     * @param {Object} memo - for internal usage during recursion
     * @returns {Object}
     */
    _makeTree(dryad: Dryad, parentId?: string, childIndex?: number | string, memo?: Memo): TreeNode;
}
declare class TreeNode {
    id: string;
    dryad: Dryad;
    dryadType: string;
    children: TreeNode[];
    constructor(id: string, dryad: Dryad, dryadType: string, children: TreeNode[]);
}
export {};
//# sourceMappingURL=DryadTree.d.ts.map