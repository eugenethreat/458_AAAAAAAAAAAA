"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * If a Dryad has Dryads in it's properties then bring then transform the playgraph.
 *
 * So this:
 *
 *  Synth({
 *    def: SCSynthDef(...)
 *  })
 *
 * is transformed to this in the playgraph:
 *
 *  Properties({}, [
 *    SCSynthDef(...),
 *    PropertiesOwner({...}, [
 *      Synth({def: accessorFunction})
 *    ])
 *  ]);
 *
 * Now the SCSynthDef is in the playgraph ahead of the Synth and can prepare and
 * compile what it needs to before the Synth needs to use the result.
 */
const clone_1 = tslib_1.__importDefault(require("lodash/clone"));
const Dryad_1 = tslib_1.__importDefault(require("./Dryad"));
const utils_1 = require("./utils");
/**
 * Parent wrapper whose children are the properties and the PropertiesOwner as siblings.
 */
class Properties extends Dryad_1.default {
    prepareForAdd() {
        return {
            callOrder: "PROPERTIES_MODE" /* PROPERTIES_MODE */,
        };
    }
}
exports.default = Properties;
/**
 * Object that holds the owner - the Dryad that had Dryads in it's .properties
 */
class PropertiesOwner extends Dryad_1.default {
    prepareForAdd(player) {
        return {
            callOrder: "SELF_THEN_CHILDREN" /* SELF_THEN_CHILDREN */,
            updateContext: (context) => {
                // Context has an id
                return {
                    propertiesValues: this.properties.indices.map((i) => {
                        // x.y.z.props.{$context.id} -> x.y.z.props.{$i}
                        if (player.tree) {
                            const propDryadId = context.id.replace(/\.([0-9]+)$/, `.${i}`);
                            const propDryad = player.tree.dryads[propDryadId];
                            const propContext = player.tree.contexts[propDryadId];
                            const value = propDryad.value(propContext);
                            return value;
                        }
                        return undefined;
                    }),
                };
            },
        };
    }
}
exports.PropertiesOwner = PropertiesOwner;
/**
 * If a Dryad contains Dryads in it's properties then return a Properties
 * that inverts the play graph so those dryadic properties come first.
 *
 * Returns a Properties or undefined if there are no Dryads in the properties.
 */
function invertDryadicProperties(dryad) {
    let ci = -1;
    const children = [];
    const indices = [];
    const cname = utils_1.className(dryad);
    if (cname === "Properties" || cname === "PropertiesOwner") {
        return;
    }
    /**
     * Map the properties to functions that will retrieve the dryad's 'value'.
     */
    const propertyAccessors = utils_1.mapProperties(dryad.properties, value => {
        if (utils_1.isDryad(value)) {
            ci = ci + 1;
            const childIndex = ci;
            // It must implement .value
            // if (!isFunction(value.value)) {
            //   throw new Error(`${value} does not implement .value; cannot use this as a .property`);
            // }
            children.push(cloneValue(value));
            indices.push(ci);
            // Here there must be propertiesValues as set by PropertiesOwner
            // in prepareForAdd. that is the direct parent of this (actual owner)
            return (context) => {
                if (!context.propertiesValues) {
                    throw new Error(`Missing propertiesValues from context ${context.id}`);
                }
                return context.propertiesValues[childIndex];
            };
        }
        else {
            return value;
        }
    });
    // There were no Dryads in .properties
    if (ci < 0) {
        return;
    }
    const owner = Object.create(dryad, {
        properties: { value: propertyAccessors },
        children: { value: dryad.children.map(cloneValue) },
    });
    children.push(new PropertiesOwner({ indices }, [owner]));
    return new Properties({}, children);
}
exports.invertDryadicProperties = invertDryadicProperties;
function cloneValue(value) {
    return utils_1.isDryad(value) ? value.clone() : clone_1.default(value);
}
//# sourceMappingURL=Properties.js.map