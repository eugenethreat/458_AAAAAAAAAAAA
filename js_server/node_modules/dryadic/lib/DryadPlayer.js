"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CommandMiddleware_1 = tslib_1.__importDefault(require("./CommandMiddleware"));
const CommandNode_1 = tslib_1.__importDefault(require("./CommandNode"));
const DryadTree_1 = tslib_1.__importDefault(require("./DryadTree"));
const hyperscript_1 = tslib_1.__importDefault(require("./hyperscript"));
const run_1 = tslib_1.__importDefault(require("./run"));
const updateContext_1 = tslib_1.__importDefault(require("./updateContext"));
/**
 * Manages play/stop/update for a Dryad tree.
 *
 * A Dryad has no state or functionality until it is played
 * by a DryadPlayer. A Dryad can be played more than once at
 * the same time by creating more DryadPlayers.
 *
 * The DryadPlayer also holds the layers and command middleware
 * which execute the functionality that the Dryads specify.
 */
class DryadPlayer {
    constructor(rootDryad = null, layers = [], rootContext = {}) {
        /**
         * Lookup Dryad class by name.
         *
         * Used by hyperscript and requireParent, this requires
         * that layers and their classes were registered and any custom
         * classes that you right are registered. If you aren't using
         * hyperscript then you don't need to register your class.
         *
         * @param className - case-insensitive
         */
        this.getClass = (className) => {
            const dryadClass = this.classes[className.toLowerCase()];
            if (!dryadClass) {
                throw new Error(`Dryad class not found: '${className}' in classes: ${Object.keys(this.classes).join(", ")}`);
            }
            return dryadClass;
        };
        this.middleware = new CommandMiddleware_1.default([updateContext_1.default, run_1.default]);
        this.classes = {};
        if (layers) {
            layers.forEach(layer => this.use(layer));
        }
        if (!rootContext.log) {
            rootContext.log = console;
        }
        this.log = rootContext.log;
        // default logger
        this._errorLogger = (msg, error) => {
            this.log.error(msg, error, error.stack);
            this.dump();
            // and emit error event
        };
        this.setRoot(rootDryad, rootContext);
    }
    /**
     * Set a new tree.
     *
     * Behavior while already playing is not yet defined.
     *
     * @param {Dryad} dryad
     */
    setRoot(dryad, rootContext = {}) {
        this.tree = dryad ? new DryadTree_1.default(this.h(dryad), this.getClass, rootContext) : undefined;
    }
    /**
     * Convert hyperscript graph to Dryad objects with registered classes
     *
     * @param {Object} hgraph - JSON style object
     * @returns {Dryad}
     */
    h(hgraph) {
        return hyperscript_1.default(hgraph, this.getClass);
    }
    /**
     * Add a layer of functionality by registering Dryad classes and command middleware.
     *
     * @param layer - .classes is a list of Dryad classes, .middleware is a list of middleware functions
     */
    use(layer) {
        this.middleware.use(layer.middleware || []);
        (layer.classes || []).forEach(c => this.addClass(c));
        return this;
    }
    /**
     * Register a Dryad class so it can be located when used in hyperscript.
     * Also needed if a class uses requireParent()
     */
    addClass(dryadClass) {
        this.classes[dryadClass.name.toLowerCase()] = dryadClass;
    }
    /**
     * Prepare Dryads in document for play.
     *
     * This allocates resources and performs any time consuming async work
     * required before the Dryads may play.
     *
     * Prepare commands may fail by rejecting their Promises.
     * Unable to allocate resource, required executables do not exist etc.
     *
     * .play commands should not fail
     *
     */
    prepare() {
        return this.call("prepareForAdd");
    }
    /**
     * Prepares and plays the current document.
     *
     * Optionally updates to a new document.
     *
     * @returns {Promise} - that resolves to `this`
     */
    async play(dryad) {
        if (dryad) {
            this.setRoot(dryad);
        }
        try {
            await this.prepare();
            await this.call("add");
            return this;
        }
        catch (error) {
            // Log the error but continue the Promise chain
            this._errorLogger("Failed to play", error);
            return Promise.reject(error);
        }
    }
    /**
     * @returns {Promise} - that resolves to `this`
     */
    async stop() {
        try {
            await this.call("remove");
            return this;
        }
        catch (error) {
            this._errorLogger("Failed to stop", error);
            return Promise.reject(error);
        }
    }
    _collectCommands(commandName) {
        if (this.tree && this.tree.tree) {
            return this.tree.collectCommands(commandName, this.tree.tree, this);
        }
        // no-op
        return new CommandNode_1.default({}, {}, {}, "", []);
    }
    /**
     * Collect commands and call for a transition: add|remove|prepareForAdd
     */
    async call(stateTransitionName) {
        const cmdTree = this._collectCommands(stateTransitionName);
        await this._call(cmdTree, stateTransitionName);
        return this;
    }
    /**
     * Execute a command tree using middleware.
     */
    async _call(commandTree, stateTransitionName) {
        if (this.tree) {
            await this.middleware.call(commandTree, stateTransitionName, (context, update) => {
                return this.tree ? this.tree.updateContext(context.id, update) : context;
            });
        }
    }
    /**
     * Execute a single command object for a single node using middleware
     * outside the prepareForAdd/add/remove full tree command execution routine.
     *
     * This can be called out of band from a Dryad's add/remove method
     *
     * Its for commands that need to be executed during runtime
     * in response to events, streams etc.
     * eg. spawning synths from an incoming stream of data.
     */
    async callCommand(nodeId, command) {
        if (this.tree) {
            await this._call(this.tree.makeCommandTree(nodeId, command), "callCommand");
        }
    }
    /**
     * updateContext - Allow a Dryad to update its own context.
     *
     * This can be called during runtime by event handlers,
     * updates via stream etc. when you need to save new values into the context
     * outside of the add/remove/update functions.
     *
     * Contexts are immutable - this returns a new context object.
     *
     * @param  {Object} context to update
     * @param  {Object} update  updated variables
     * @return {Object}         new context object
     */
    updateContext(context, update) {
        return this.tree ? this.tree.updateContext(context.id, update) : context;
    }
    /**
     * Get a representation of current state of the tree.
     * Contains add|remove|prepared and may hold errors.
     */
    getDebugState() {
        return this.tree ? this.tree.getDebugState() : {};
    }
    /**
     * Get hyperscript representation of current (expanded) play graph
     */
    getPlayGraph() {
        return this.tree && this.tree.hyperscript();
    }
    dump() {
        // TODO: get a better one
        function replacer(key, value) {
            if (typeof value === "function") {
                return String(value);
            }
            return value;
        }
        this.log.info(JSON.stringify(this.getPlayGraph(), replacer, 2));
        this.log.error(JSON.stringify(this.getDebugState(), replacer, 2));
    }
}
exports.default = DryadPlayer;
//# sourceMappingURL=DryadPlayer.js.map